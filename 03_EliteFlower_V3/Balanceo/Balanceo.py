print("soy una funcion de python")
# -*- coding: utf-8 -*-
"""ALGORITMO_BALANCEO_ELITE_PYTHON.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1BlaA48w4FHk1hIh_PjzrD-2CPzobT5Uy
# DEFINICIÓN DE FUNCIONES
"""
from itertools import combinations, count
import json
from lib2to3.pytree import convert
from multiprocessing import connection
from os import getcwd
from xmlrpc.client import boolean 
from numpy.lib.function_base import append
import random
from csv import excel
import pandas as pd
import numpy as np
import pickle
import sys

"""
***********************************
Funcion para el balanceo de 1 Vase
***********************************
"""

def balanceo_1_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, manual):
  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio = 0
    elif (r == 2 ):
      inicio = 3
    else:
      inicio = 6

    print(f'Inicio = {inicio}')
    if manual == "1": 
      pass
    else:
      for k in range(inicio,inicio+3,1):
        Distribucion_estaciones[k]  = Vases_ID[0]

  elevadores_asignados = []
  elevadores_asignados_aux = []


  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]

  if '-1' in Vases_ID:
     elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []
  print(f'Vases ID[0] = {Vases_ID[0]}')
  print(f'elevadores aux = {elevadores_asignados_aux}')
  print(f'elevadores = {elevadores_asignados}')
  print(f'Vases = {Vases_count}')

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    #random.shuffle(lista_aux)   #Aleatorizar
    elevador_ID.append(lista_aux)
  
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 2 Vases
***********************************
"""


def balanceo_2_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):  

  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]


  cant1 = Vases_count[0]
  cant2 = Vases_count[1]
  case = 0
  print(f'cant  1 = {cant1}')
  if manual != "1":
    if cant_st == 1:
      estacion = [V_P1, V_P1, V_P2]
      random.shuffle(estacion)
    elif cant_st == 2:
      if cant1 / 5 >= cant2:
        case = 1
        aux_1 = [V_P1, V_P1, V_P1]   
        aux_2 = [V_P1, V_P1, V_P2]
      elif cant1 / 4 >= cant2:
        case = 2
        aux_1 = [V_P1, V_P1, V_P1]   
        aux_2 = [V_P1, V_P2, V_P2]
      else:
        case = 3
        aux_1 = [V_P1, V_P1, V_P2]   
        aux_2 = [V_P1, V_P2, V_P2]

      random.shuffle(aux_1)
      random.shuffle(aux_2)
      estacion = [aux_1,aux_2]
      random.shuffle(estacion)
    else:
      if cant1 / 8 > cant2:
        aux_1 = [V_P1, V_P1, V_P2]   
        aux_2 = [V_P1, V_P1, V_P1]
        aux_3 = [V_P1, V_P1, V_P1]

      elif cant1 / 7 > cant2 / 2:
        aux_1 = [V_P1, V_P1, V_P2]   
        aux_2 = [V_P1, V_P1, V_P2]
        aux_3 = [V_P1, V_P1, V_P1]

      elif cant1 / 6 > cant2 / 3:
        aux_1 = [V_P1, V_P1, V_P2]   
        aux_2 = [V_P1, V_P1, V_P2]
        aux_3 = [V_P1, V_P1, V_P2]

      else:
        aux_1 = [V_P1, V_P2, V_P2]   
        aux_2 = [V_P1, V_P1, V_P2]
        aux_3 = [V_P1, V_P1, V_P2]
      
      random.shuffle(aux_1)
      random.shuffle(aux_2)
      random.shuffle(aux_3)
      estacion = [aux_1,aux_2,aux_3]
      random.shuffle(estacion)

    print(f'estacion {estacion}')
    inicio = []

    for i in range(cant_st):
      r = var_ext_estaciones_slc[i]
      if (r == 1 ):
        inicio.append(0)
      elif (r == 2 ):
        inicio.append(3)
      else:
        inicio.append(6)
 
    if cant_st > 1 :
      for i in range(cant_st):
        n=0
        for j in range(inicio[i],inicio[i]+3,1):
          Distribucion_estaciones[j]= estacion[i][n]
          n+=1
    else:
      for i in range(cant_st):
        n=0
        for j in range(inicio[i],inicio[i]+3,1):
          Distribucion_estaciones[j]= estacion[n]
          n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []

  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  
  

  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  if cant_st == 2:
    #Determinar la cantidad de vases por elevador para asegurar el balanceo
    vases_por_st = int(round(total_con_vase / cant_st))
    cant_vase_m_por_elv = int(round(Cantidades[V_P2]/3))
    x = vases_por_st - (2*cant_vase_m_por_elv) 
   
    ubi = []
    for i in range(0,9,3):
      auxiliar = Distribucion_estaciones[i:i+3]
      if auxiliar.count(V_P1) == 1:
        ubi.append(auxiliar.index(V_P1) + i + 1)
  
    print(f'ubi = {ubi}')

 


    elevador_ID = []
    lista_aux = []

    if len(ubi)>0:
      for i in range(len(elevadores_asignados)):
        lista_aux = []
        if (Vases_ID[i] == V_P1):
          R=list(elevadores_asignados[i])
          print(f'lista {R}')
          for k in range(len(ubi)):
            R.remove(ubi[k])
            print(f'lista {R}')
            for r in range(x):
              lista_aux.append(ubi[k])
          j = 0
          for t in range (Vases_count[i]-x):
            if j>(len(R)-1):
              j=0
            lista_aux.append(R[j])
            j=j+1
          random.shuffle(lista_aux)
        else:
          j = 0
          for t in range (Vases_count[i]):
            if j>(len(elevadores_asignados[i])-1):
              j=0
            lista_aux.append(elevadores_asignados[i][j])
            j=j+1
        elevador_ID.append(lista_aux)
    else:
      elevador_ID = []
      lista_aux = []

      for w in range(len(elevadores_asignados)):
        lista_aux = []
        j = 0
        for i in range (Vases_count[w]):
          if j>(len(elevadores_asignados[w])-1):
            j=0
          lista_aux.append(elevadores_asignados[w][j])
          j=j+1
        elevador_ID.append(lista_aux)

  else:
    elevador_ID = []
    lista_aux = []

    for w in range(len(elevadores_asignados)):
      lista_aux = []
      j = 0
      for i in range (Vases_count[w]):
        if j>(len(elevadores_asignados[w])-1):
          j=0
        lista_aux.append(elevadores_asignados[w][j])
        j=j+1
      elevador_ID.append(lista_aux)
#elevador ID, vector con la posicion del codigo i referente al vase en los elevadores
  # for i in range(len(elevador_ID)):
  #  print(f'len ID {i} = {len(elevador_ID[i])}')
  #  for j in range(30):
  #   print(f'ID 0 = {elevador_ID[i][j]}')
#Elevadores Asignados, contiene una lista de listas con las posiciones en las que se encuetran
# cada uno de los vases de la base de datos
  print(f'elevadores asignados {elevadores_asignados}')
   
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 3 Vases
***********************************
"""

def balanceo_3_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];

  cant1 = Vases_count[0]
  cant2 = Vases_count[1]
  cant3 = Vases_count[2]

  estacion = []
  if cant_st == 1:
    estacion = [V_P1, V_P2, V_P3]
  elif cant_st == 2:
    if cant1 / 4 > cant2:
     aux_1 = [V_P1, V_P1, V_P2]
     aux_2 = [V_P1, V_P1, V_P3]
    else:
     aux_1 = [V_P1, V_P1, V_P2]
     aux_2 = [V_P1, V_P2, V_P3]
    random.shuffle(aux_1)
    random.shuffle(aux_2)   
    estacion = [aux_1,aux_2]
    random.shuffle(estacion)
  else:
    if cant1 / 7 > cant2:
       aux_1 = [V_P1, V_P1, V_P2]   
       aux_2 = [V_P1, V_P1, V_P3]
       aux_3 = [V_P1, V_P1, V_P1]
    elif cant1 / 6 > cant2 /2 and cant1 / 6 > cant3:
       aux_1 = [V_P1, V_P1, V_P2]   
       aux_2 = [V_P1, V_P1, V_P3]
       aux_3 = [V_P1, V_P1, V_P2]      
    elif cant1 / 5 > cant2 /2 and cant1 / 6 > cant3 / 2:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P1, V_P3]
       aux_3 = [V_P1, V_P1, V_P2]   
    elif cant1 / 5 > cant2 /3 and cant1 / 5 > cant3:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P1, V_P2]
       aux_3 = [V_P1, V_P1, V_P2]
    elif cant1 / 4 > cant2 /4 and cant1 / 4 > cant3:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P2, V_P2]
       aux_3 = [V_P1, V_P1, V_P2]  
    elif cant1 / 4 > cant2 /3 and cant1 / 4 > cant3 / 2:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P2, V_P3]
       aux_3 = [V_P1, V_P1, V_P2] 
    elif cant1 / 4 > cant2 /3 and cant1 / 4 > cant3 / 2:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P2, V_P3]
       aux_3 = [V_P1, V_P1, V_P2]
    else:
       aux_1 = [V_P1, V_P2, V_P3]   
       aux_2 = [V_P1, V_P2, V_P3]
       aux_3 = [V_P1, V_P2, V_P3]
    random.shuffle(aux_1)
    random.shuffle(aux_2)  
    random.shuffle(aux_3) 
    estacion = [aux_1,aux_2,aux_3]
    random.shuffle(estacion) 
  inicio = []

  print(f'Estacion = {estacion}')
  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  



  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1  

  print(f'distribucion estaciones {Distribucion_estaciones}')

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])
  
  print(f'elevadores asginados {elevadores_asignados}')
  elevador_ID = []
  lista_aux = []

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 4 Vases
***********************************
"""

def balanceo_4_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];
  V_P4 = sort_cantidades[3][0];

  cant1 = Vases_count[0]
  cant2 = Vases_count[1]
  cant3 = Vases_count[2]
  cant4 = Vases_count[3]



  if cant1/total_con_vase > 0.8:
    if cant_st == 2:
      aux_1 = [V_P1, V_P2, V_P3]
      aux_2 = [V_P1, V_P1, V_P4]
    else:
      aux_1 = [V_P1, V_P1, V_P2]
      aux_2 = [V_P1, V_P1, V_P3]
      aux_3 = [V_P1, V_P1, V_P4]
  elif cant1/total_con_vase > 0.5 and cant2/total_con_vase > 0.3:
    if cant_st == 2:
      aux_1 = [V_P1, V_P2, V_P3]
      aux_2 = [V_P1, V_P2, V_P4]
    else:
      aux_1 = [V_P1, V_P1, V_P2]
      aux_2 = [V_P1, V_P2, V_P3]
      aux_3 = [V_P1, V_P1, V_P4]
  else:
    if cant_st == 2:
      aux_1 = [V_P1, V_P2, V_P3]
      aux_2 = [V_P1, V_P2, V_P4]
    else:
      aux_1 = [V_P1, V_P2, V_P3]
      aux_2 = [V_P1, V_P3, V_P4]
      aux_3 = [V_P1, V_P2, V_P4]

  estacion = []
  random.shuffle(aux_1)
  random.shuffle(aux_2)

  if cant_st == 2:
    estacion = [aux_1,aux_2]
  else:
    random.shuffle(aux_3)
    estacion = [aux_1,aux_2,aux_3]
  random.shuffle(estacion) 

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass




  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  rv = []

  rv.append(Distribucion_estaciones.count(V_P1))
  rv.append(Distribucion_estaciones.count(V_P2))
  rv.append(Distribucion_estaciones.count(V_P3))
  rv.append(Distribucion_estaciones.count(V_P4))

  print(f'rv = {rv}')


  vases_por_st = int(round(total_con_vase / cant_st))

 
  
  elevador_ID = []
  lista_aux = []




  if cant_st == 2:
    y = int(round(Cantidades[V_P2]/cant_st)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    #Estacion con V_P3 y V_P2
    x = int(round(vases_por_st - (y + Cantidades[V_P3]/(cant_st-1))))

    if var_ext_estaciones_slc[0] == 1:
      ea_st1 = [1,2,3]
    else:
      ea_st1 = [4,5,6]
    if var_ext_estaciones_slc[1] == 2:
      ea_st2 = [4,5,6]
    else:
      ea_st2 = [7,8,9]
    
    

    gr1 = []
    gr2 = []

    for i in range(len(elevadores_asignados[0])):
      if elevadores_asignados[0][i] in ea_st1:
        gr1.append(elevadores_asignados[0][i])
      elif elevadores_asignados[0][i] in ea_st2:
        gr2.append(elevadores_asignados[0][i])


      

    print(f'grupo 1 = {gr1}, grupo 2 = {gr2}')

 
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      k = 0
      j = 0
      if (Vases_ID[i] == V_P1): # distribuye el vase con mayor cantidad de pedidos
        if len(gr1) > 0 and len(gr2) == 0:
          for h in range(Vases_count[i]):           
            lista_aux.append(gr1[k])
            k += 1
            if k > len(gr1)-1:
              k = 0 
        elif len(gr1) == 0 and len(gr2) > 0:
          for h in range(Vases_count[i]):
            lista_aux.append(gr2[k])
            k += 1
            if k > len(gr2)-1:
              k = 0                    
        else:
          for h in range(Vases_count[i]-x):
            lista_aux.append(gr1[k])
            k += 1
            if k > len(gr1)-1:
              k = 0

          for h in range(x):
            lista_aux.append(gr2[j])
            j+= 1
            if j > len(gr2)-1:
              j = 0
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)

  else:
    gr1 = []
    gr2 = []
    gr3 = []
    k = 0
    j = 0
    p = 0
 




    for i in range(len(elevadores_asignados[0])):
      if elevadores_asignados[0][i] in [1,2,3]:
        gr1.append(elevadores_asignados[0][i])
      elif elevadores_asignados[0][i] in [4,5,6]:
        gr2.append(elevadores_asignados[0][i])
      elif elevadores_asignados[0][i] in [7,8,9]:
        gr3.append(elevadores_asignados[0][i])

    print(f'grupo1 {gr1}, grupo2 {gr2}, grupo3 {gr3}')
    x = Vases_count

    cant_st_v2 = int(round(cant2/ rv[1]))
    cant_st_v3 = int(round(cant3/ rv[2]))   
    cant_st_v4 = int(round(cant4/ rv[3]))

    cant = {V_P2 : cant_st_v2, V_P3 : cant_st_v3, V_P4 : cant_st_v4 }

    print(f'cant = {cant}')

    """y : variable en la cual se calcula las cantidades por estacion de todos
    los vases, excepto el que mas cantidad tiene
    """
    y = []
    print(f'estacion {estacion}')
    for i in range(len(estacion)):
      aux = 0
      for j in range(len(estacion[i])):
        if estacion[i][j] != V_P1:
          print(estacion[i][j])
          aux += cant[estacion[i][j]]
      y.append(aux)
    
    print(f'y = {y}')
    """En X se calcula la cantidad del vase que mas se repita por estacion
    tomando a consideración los valores asignados en las demas estaciones
    con el fin de equiparar lo mas posible la carga
    """
    
    x = []

    for i in range(len(y)):
      if (total_con_vase/3-y[i]) > 0:
        x.append(int(round(total_con_vase/3)-y[i]))
      else:
        x.append(int(0))
      
      
      
    surplus = cant1-(x[0]+x[1]+x[2])
    x[0] += surplus

    print(f'x = {x}')




    # y = int(round(Cantidades[V_P2]/cant_st)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    #  #Estacion con V_P3 y V_P2
    # x = int(round(vases_por_st - (y + Cantidades[V_P3]/(cant_st-1))))

    for i in range(len(elevadores_asignados)):
      lista_aux = []
      k = 0; j = 0; p = 0
      if (Vases_ID[i] == V_P1):
        if len(gr1)> 0:
          for h in range(x[0]):
            lista_aux.append(gr1[k])
            k += 1
            if k > len(gr1)-1:
              k = 0
        if len(gr2)> 0:
          for h in range(x[1]):
            lista_aux.append(gr2[j])
            j += 1
            if j > len(gr2)-1:
              j = 0
        if len(gr3)> 0:
          for h in range(x[2]):
            lista_aux.append(gr3[p])
            p += 1
            if p > len(gr3)-1:
              p = 0
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  print(f'elevadores asignados {elevadores_asignados}')
  return elevadores_asignados, elevador_ID


"""
***********************************
Funcion para el balanceo de 5 Vases
***********************************
"""

def balanceo_5_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];
  V_P4 = sort_cantidades[3][0];
  V_P5 = sort_cantidades[4][0];

  estacion = []
  x=[]

  if cant_st == 2:
    aux_1 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P3, V_P4]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    estacion = [aux_1,aux_2]
  else:
    aux_1 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P2, V_P4] # De la estación 1 se despeja x[1]
    aux_3 = [V_P1, V_P2, V_P3]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    random.shuffle(aux_3)
    estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  vases_por_st = int(round(total_con_vase / cant_st))

  elevador_ID = []
  lista_aux = []
  x=[]

  #Estacion con V_P3 y V_P2
  if cant_st == 2:
    x += [int(round(vases_por_st - (Cantidades[V_P2] + Cantidades[V_P5])))]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i]-x[0]):
          lista_aux.append(elevadores_asignados[i][1])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)

  else:
    y = int(round(Cantidades[V_P2]/cant_st)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    x += [int(round(vases_por_st - (y + Cantidades[V_P5])))] #x[0]
    x += [int(round(vases_por_st - (y + Cantidades[V_P4])))] #x[1]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i] - x[0] - x[1]):
          lista_aux.append(elevadores_asignados[i][2])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x[1]):
          lista_aux.append(elevadores_asignados[i][1])
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 6 Vases
***********************************
"""

def balanceo_6_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]

  estacion = []
  x=[]

  if cant_st == 2:

    lista_ids_por_orden = []
    for i in range(len(sort_cantidades)):
      lista_ids_por_orden.append(sort_cantidades[i][0])
    
    Posb_Comb = []
    for c in combinations(lista_ids_por_orden, 3):
      Posb_Comb.append(c)

    suma_vases_posb_st=[]
    for i in range(len(Posb_Comb)):
      a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])][1]
      b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])][1]
      c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])][1]
      aux = a+b+c
      suma_vases_posb_st.append(aux)
    
    porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/2)))
    x = suma_vases_posb_st.index(porcentaje_mas_cercano)
    Ord_St_1 = list(Posb_Comb[x])
    
    Ord_St_2 = list(lista_ids_por_orden)
    for i in Ord_St_1:
      Ord_St_2.remove(i)
    
    random.shuffle(Ord_St_1)
    random.shuffle(Ord_St_2)
    estacion = [Ord_St_1,Ord_St_2]

  else:
    aux_1 = [V_P1, V_P2, V_P6] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[1]
    aux_3 = [V_P1, V_P3, V_P4]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    random.shuffle(aux_3)
    estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []
  x=[]

  if cant_st == 2:
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      for t in range (Vases_count[i]):
        lista_aux.append(elevadores_asignados[i][0])
      elevador_ID.append(lista_aux)
    
  else:
    vases_por_st = int(round(total_con_vase / cant_st))
    y = int(round(Cantidades[V_P2]/2)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    x += [int(round(vases_por_st - (y + Cantidades[V_P6])))] #x[0]
    x += [int(round(vases_por_st - (y + Cantidades[V_P5])))] #x[1]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i] - x[0] - x[1]):
          lista_aux.append(elevadores_asignados[i][2])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x[1]):
          lista_aux.append(elevadores_asignados[i][1])
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 7 Vases
***********************************
"""

def balanceo_7_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual):  
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]

  estacion = []
  x=[]
  
  aux_1 = [V_P1, V_P2, V_P7] # De la estación 1 se despeja x[0]
  aux_2 = [V_P1, V_P3, V_P6] # De la estación 2 se despeja x[1]
  aux_3 = [V_P1, V_P4, V_P5]
  random.shuffle(aux_1)
  random.shuffle(aux_2)
  random.shuffle(aux_3)
  estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  x=[]


  vases_por_st = int(round(total_con_vase / cant_st)) 
  x += [int(round(vases_por_st - (Cantidades[V_P2] + Cantidades[V_P7])))] #estacion 1 x[0]
  x += [int(round(vases_por_st - (Cantidades[V_P3] + Cantidades[V_P6])))] #estacion 2 x[1]

  if Cantidades[V_P2] >= 23 and Cantidades[V_P7] >=10: x[0] = 0

  for i in range(len(elevadores_asignados)):
    lista_aux = []
    if (Vases_ID[i] == V_P1):
      for h in range(Vases_count[i] - x[0] - x[1]):
        lista_aux.append(elevadores_asignados[i][2])
      for h in range(x[0]):
        lista_aux.append(elevadores_asignados[i][0])
      for h in range(x[1]):
        lista_aux.append(elevadores_asignados[i][1])
      random.shuffle(lista_aux)
    else:
      j = 0
      for t in range (Vases_count[i]):
        if j>(len(elevadores_asignados[i])-1):
          j=0
        lista_aux.append(elevadores_asignados[i][j])
        j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 8 Vases
***********************************
"""

def balanceo_8_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual): 
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]
  V_P8 = sort_cantidades[7][0]

  estacion = []

  lista_ids_por_orden = []

  for i in range(len(sort_cantidades)):
    lista_ids_por_orden.append(sort_cantidades[i][0])

  lista_ids_por_orden.remove(V_P1)

  Posb_Comb = []
  for c in combinations(lista_ids_por_orden, 3):
    Posb_Comb.append(c)

  suma_vases_posb_st=[]
  for i in range(len(Posb_Comb)):
    a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])+1][1]
    b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])+1][1]
    c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])+1][1]
    aux = a+b+c
    suma_vases_posb_st.append(aux)

  porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/3)))
  indice = suma_vases_posb_st.index(porcentaje_mas_cercano)
  Ord_St_1 = list(Posb_Comb[indice])

  for i in Ord_St_1:
    lista_ids_por_orden.remove(i)

  Ord_St_2 = [V_P1,lista_ids_por_orden[0],lista_ids_por_orden[3]]
  Ord_St_3 = [V_P1,lista_ids_por_orden[1],lista_ids_por_orden[2]]

  aux_vase_St_2 = list(Ord_St_2)

  random.shuffle(Ord_St_1)
  random.shuffle(Ord_St_2)
  random.shuffle(Ord_St_3)
  estacion = [Ord_St_1,Ord_St_2,Ord_St_3] #El orden debe ser extricto 

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)
  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []

  vases_por_st = int(round(total_con_vase / cant_st))
  x = [int(round(vases_por_st - (Cantidades[aux_vase_St_2[1]] + Cantidades[aux_vase_St_2[2]])))] # X de la estación 2

  for i in range(len(elevadores_asignados)):
    lista_aux = []
    if (Vases_ID[i] == V_P1):
      for h in range(Vases_count[i] - x[0]):
        lista_aux.append(elevadores_asignados[i][1])
      for h in range(x[0]):
        lista_aux.append(elevadores_asignados[i][0])
      random.shuffle(lista_aux)
    else:
      j = 0
      for t in range (Vases_count[i]):
        if j>(len(elevadores_asignados[i])-1):
          j=0
        lista_aux.append(elevadores_asignados[i][j])
        j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 9 Vases
***********************************
"""

def balanceo_9_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual): 
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]
  V_P8 = sort_cantidades[7][0]
  V_P9 = sort_cantidades[8][0]

  estacion = []

  lista_ids_por_orden = []

  for i in range(len(sort_cantidades)):
    lista_ids_por_orden.append(sort_cantidades[i][0])

  Lista_AUX = list(lista_ids_por_orden)

  for r in range(2):
    Posb_Comb = []
    
    for c in combinations(Lista_AUX, 3):
      Posb_Comb.append(c)
    suma_vases_posb_st=[]
    
    for i in range(len(Posb_Comb)):
      a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])][1]
      b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])][1]
      c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])][1]
      aux = a+b+c
      suma_vases_posb_st.append(aux)
    
    porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/3)))
    indice = suma_vases_posb_st.index(porcentaje_mas_cercano)
    Ord_St_ = list(Posb_Comb[indice])
    for i in Ord_St_:
      Lista_AUX.remove(i)
    random.shuffle(Ord_St_)
    estacion.append(Ord_St_)

  random.shuffle(Lista_AUX)
  estacion.append(Lista_AUX)
  random.shuffle(estacion) 

  inicio = [0,3,6]

  if manual != "1":
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    pass

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID


"""# CARGAR BASE DE DATOS

   var_ext_estaciones_slc : vector con las estaciones activas
   df_original: string con la direccion local de la base de datos en excel
   manual: boleano 0-1 que indica si es balanceo manual o automatico
   CV: vector con la configuracion usada en el balanceo manual
"""

def balanceo_automatico(var_ext_estaciones_slc, df_original, manual, CV):





  # Se carga la base de datos desde el archivo de excel

  #df_original = pd.read_excel('/content/DB_PRUEBA_1_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_2_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_3_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_4_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_5_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_6_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_7_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_8_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_9_V.xlsx')
  df_original = pd.read_excel (df)
  #print (df_original)
  df_original = df_original.replace(np.nan,'-1')
  db_g = df_original.groupby('VASE_ID', dropna=False).agg(list)
  #print("base de datos")
  #print(db_g)
  dp = getcwd()
  #file1 = open(rf'{dp}\intercambio.txt', "wb") # cambiar la direccion de guardado de acuerdo al proyecto, solo cambiar ruta, wb se mantiene
  #pickle.dump(db_g, file1)
  #file1.close

  """#PROCESAR"""

  #with open(rf'{dp}\intercambio.txt', 'rb') as f:
      #db_group = pickle.load(f)
  db_group = db_g    
  #print(db_group)
  Vases_ID = db_group.index.values
  Barcodes = db_group.BARCODE_NUMBER.values
  AddOn_List = db_group.ADD_ON_ID.values
  Total_ordenes = 0;
  for i in range(Barcodes.shape[0]):
    Total_ordenes += len(Barcodes[i]) 

  if '-1' in Vases_ID:
    Vases_ID = np.roll(Vases_ID, -1)
    Barcodes = np.roll(Barcodes, -1)
    AddOn_List = np.roll(AddOn_List, -1)
    Vases_type_num = db_group.index.size - 1
    N_V = len(Barcodes[-1])
  else:
    Vases_type_num = db_group.index.size - 1
    N_V = 0

  Vases_count = np.zeros((Vases_ID.size), dtype=int)
  for i in range(Vases_ID.size):
    Vases_count[i]=len(Barcodes[i])

  AddOn_ID = ["","",""]
  for i in range(len(AddOn_List)):
    AddOn_ID = np.append(AddOn_ID,np.unique(AddOn_List[i]))
  AddOn_ID = np.unique(AddOn_ID)
  if '-1' in AddOn_ID:
    AddOn_ID = np.delete(AddOn_ID,np.where(AddOn_ID =='-1')[0][0])

  AddOn_count=[0,0,0]
  aux = []
  aux1 = []

  for i in range(AddOn_List.size):
    aux = []
    a = AddOn_List[i]
    for j in range(AddOn_ID.size):
      b = a.count(AddOn_ID[j])
      aux.append(b)
    aux1.append(aux)
  aux1 = np.array(aux1)

  AddOn_count = np.sum(aux1, axis=0)

  total_con_vase = 0
  for i in range(Vases_type_num):
    total_con_vase = total_con_vase + Vases_count[i]

  Cantidades = {}
  for i in range(Vases_type_num):
    Cantidades[Vases_ID[i]] = Vases_count[i]

  # take the second element for sort
  def take_second(elem):
      return elem[1]

  sort_cantidades = sorted(Cantidades.items(),  key=take_second, reverse=True)

  ### ESTO ES UNA ENTRADA DIRECTA DE LA UI ###
  ## INGRESAR UNA LISTA CON LAS ESTACIONES SELECCIONADAS
  #Se escogen cuantas y cuales estaciones seran utilizadas #
  #var_ext_estaciones_slc = ['3']
  #var_ext_estaciones_slc = ['2','1']
  #var_ext_estaciones_slc = ['2','3','1']
  var_ext_estaciones_slc = list(map(int, var_ext_estaciones_slc))
  var_ext_estaciones_slc.sort()
  cant_st = len(var_ext_estaciones_slc)
  Distribucion_estaciones = ['-1','-1','-1','-1','-1','-1','-1','-1','-1'] # elevadores
 
  if manual == "1":
    Distribucion_estaciones = CV
    
  
  if cant_st*3 < Vases_type_num:
    print("!ERROR! -> La cantidad de vases supera el número de elevadores seleccionados")

  else:
    #print(f"Addon Id: {AddOn_ID}")
    Led_Pos = ['N_A','N_A','N_A']
    for i in range(AddOn_ID.size):
      Led_Pos[i] = AddOn_ID[i]

    lista_aux = []
    Led_ID = []

    for i in range(AddOn_List.size):
      lista_aux = []
      for j in range(len(AddOn_List[i])):
        if AddOn_List[i][j] == '-1':
          lista_aux.append('-1')
        elif AddOn_List[i][j] == Led_Pos[0]:
          lista_aux.append('1')
        elif AddOn_List[i][j] == Led_Pos[1]:
          lista_aux.append('2')
        elif AddOn_List[i][j] == Led_Pos[2]:
          lista_aux.append('3')
      Led_ID.append(lista_aux)

    strg_to_print = ""
    for j in range(Vases_type_num):
      strg_to_print += str(Vases_count[j]) + ' órdenes con ' + Vases_ID[j] +"\n"

    strg_to_print = strg_to_print + str(N_V) + ' órdenes sin vase '

    print("Total de órdenes ingresadas = " + str(Total_ordenes))
    print(strg_to_print)

    strg_to_print = ""
    for j in range(AddOn_count.size):
      strg_to_print += "\n" + str(AddOn_count[j]) + ' órdenes con addon ' + AddOn_ID[j]

    print(strg_to_print)

  """# BALANCEO AUTOMÁTICO"""

  print(f'Numero de Vases {Vases_type_num}')
  print(f'Estaciones seleccionadas: {cant_st}')
  print(f'Estaciones : {var_ext_estaciones_slc}')
  print(f'Distribucion de estaciones : {Distribucion_estaciones}')
  print(f'Vases ID : {Vases_ID}')
  print(f'Vases Type Num : {Vases_type_num}')
  print(f'Vases Count : {Vases_count}')

  if Vases_type_num == 1:
    elevadores_asignados, elevador_ID = balanceo_1_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, manual)
  elif Vases_type_num == 2:
    elevadores_asignados, elevador_ID = balanceo_2_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 3:
    elevadores_asignados, elevador_ID = balanceo_3_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 4:
    elevadores_asignados, elevador_ID = balanceo_4_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 5:
    elevadores_asignados, elevador_ID = balanceo_5_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 6:
    elevadores_asignados, elevador_ID = balanceo_6_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 7:
    elevadores_asignados, elevador_ID = balanceo_7_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 8:
    elevadores_asignados, elevador_ID = balanceo_8_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)
  elif Vases_type_num == 9:
    elevadores_asignados, elevador_ID = balanceo_9_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades, manual)

  """# SALIDA Y VISUALIZACIÓN DE LA BASE DE DATOS CON LA ASIGNACIÓN EJECUTADA"""

  base_datos_output = []

  for w in range(len(Vases_ID)):
    CdB = Barcodes[w]
    V_ID = Vases_ID[w]
    AO_ID = AddOn_List[w]
    ELEV_ID = elevador_ID[w]
    LED_AO = Led_ID[w]
    for q in range(Vases_count[w]):
      lista_aux = [CdB[q], V_ID, ELEV_ID[q], AO_ID[q],LED_AO[q]]
      base_datos_output.append(lista_aux)

  Cuenta_Elevador = []
  for i in range(9):
    acumulador = 0
    for k in range(len(elevador_ID)):
      acumulador +=  elevador_ID[k].count(i+1)
    Cuenta_Elevador.append(acumulador)

  Balanceo = []
  for i in range (len(Distribucion_estaciones)):
    Balanceo.append([Distribucion_estaciones[i],Cuenta_Elevador[i]])

  Dist_Led_AD =[]
  for i in range(AddOn_ID.size):
    Dist_Led_AD.append((AddOn_ID[i],AddOn_count[i]))

  print("Total de órdenes ingresadas con vase = " + str(total_con_vase))
  print("Pedidos con vases ordenados de mayor a menor:", sort_cantidades)
  print("Estaciones seleccionadas:", var_ext_estaciones_slc)
  print("Distribución en los elevadores: ", Distribucion_estaciones)
  print("Balanceo ejecutado:", Balanceo)
  print("Leds Add-On:", Dist_Led_AD)

  panda_df = pd.DataFrame(data = base_datos_output, columns = ["BARCODE_NUMBER", "VASE_ID", "ELEVATOR_ASIGN","ADD_ON_ID","LED_ASIGN"])
 #panda_df


  get_db_statics(Total_ordenes,total_con_vase, sort_cantidades, var_ext_estaciones_slc, Balanceo,Distribucion_estaciones,Cuenta_Elevador, Dist_Led_AD, AddOn_ID, AddOn_count)
  return base_datos_output
  """# Crear y cargar TXTs
  """
"""
  #Creo
  file1 = open("/intercambio.txt", "wb")
  pickle.dump(df_agrupado, file1)
  file1.close
  #Cargo
  with open('/intercambio.txt', 'rb') as f:
      db_group = pickle.load(f)
"""

"""
****************************************************************
Asignación de variables para prueba, comentar en la aplicación
****************************************************************
"""
def get_database(data):
    import pymongo
    client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')
    db = client['EliteFlower']
    print(client)
    #print(data)


    
    balanceData = db.balanceData
    balanceData.delete_many({}) #borra todos los elementos de la coleccion
    Data = db.Data
    whstage = -1
    for item in data:
      #print(item[4])
      if item[3] == -1:
        Whstage = -1
      else:
        whstage = 1
      if item[1] == "-1": 
        item[1] = "null"
      else:
        pass
      if item[3] == "-1":
        item[3] = "null"
      else:
        pass

      jsondata = {'TrackingNumber': item[0],
                  'Vase': item[1],
                  'Balance': item[2],
                  'AddOnId':item[3],
                  'AddOnBalance': item[4],
                  'WhStage': whstage                 
                 }
      balanceData.insert_one(jsondata)
      db.Data.update_many({"TrackingNumber":item[0]},{"$set":{'Vase': item[1],'Balance': item[2],'AddOnId':item[3],'AddOnBalance': item[4],'WhStage': whstage}})
    client.close()

def Convert(tup, di):
    di = dict(tup)
    return di
    

def get_db_statics(Total_ordenes,total_con_vase, sort_cantidades, var_ext_estaciones_slc, Balanceo,Distribucion_estaciones,Cuenta_Elevador, Dist_Led_AD,AddOn_ID, AddOn_count):
  print('from statics')
  import pymongo
  from collections import defaultdict
  client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')
  db = client['EliteFlower']
  #print(client)

  Statics = db.Statics
  Statics.delete_many({}) #borra todos los elementos de la coleccion

  # record = {'Total con Vase':total_con_vase,
  #           'Ordenes segun Vase':sort_cantidades,
  #           'Estaciones seleccionadas':var_ext_estaciones_slc,
  #           'Distribucion':Distribucion_estaciones,
  #           'Balanceo': Balanceo,
  #           'AddON': Dist_Led_AD}
  # Driver Code    

  dictionary = {} 
  dic_sort_cant = Convert(sort_cantidades,dictionary)
  for keys in dic_sort_cant:
    dic_sort_cant[keys] = str(dic_sort_cant[keys])


  dictionary = {} 
  dic_AddON = Convert(Dist_Led_AD,dictionary)
  for keys in dic_AddON:
    dic_AddON[keys] = str(dic_AddON[keys])

  print (f'Estaciones = {type(Distribucion_estaciones)}')
  print (f'addon = {type(AddOn_ID)}')
  record = { "_id" : 1,
            "Total_Orders": str(Total_ordenes),
            "Total_Vases": str(total_con_vase),
            "Orders": dic_sort_cant, 
            "Active_Stations": var_ext_estaciones_slc,
            "Estaciones": Distribucion_estaciones,
            "Cuenta_Estaciones" : Cuenta_Elevador,
             "AddON" : AddOn_ID.tolist(),
             "Cuenta_AddON" : AddOn_count.tolist()
            # "File" : "Data"
            }

  print(record)

 

  #result = json.dumps(record)
  
  #print(result)
  #record_j = json.dumps(record)
  

  #print(record_j)

  Statics.insert_one(record)
  client.close()



      


 
    
# This is added so that many files can reuse the function get_database()


dp = 'D:\GitHub\EliteFlowerDeploy_V3\03_EliteFlower_V3'   # direccion del proyecto


#dp = getcwd(
var_ext_estaciones_slc = [sys.argv[1],sys.argv[2],sys.argv[3]]
estaciones_activas = []
print(sys.argv[4])

if ((sys.argv[4]) == "FilePath: "): 
  df = 'D:\GitHub\EliteFlowerDeploy_V3\DataBases\Prueba_Python.xlsx' #direccion de la base de datos
else:
  print("df es =")  
  df = sys.argv[4]


manual = sys.argv[5]

SV = []
for  i in range(9):
  SV.append(sys.argv[i+6])

print(SV)  
#print(df)
s = 'True'
#print(len(var_ext_estaciones_slc))
i = 1
for item in var_ext_estaciones_slc:
  #print(item)
  if item == s:
    estaciones_activas.append(i)
    i +=1 
  else:
    i +=1 
    pass


#print(estaciones_activas) 

balanced_Data = balanceo_automatico(estaciones_activas,df, manual, SV)
# print("Data balanceda = ")
# #for item in balanced_Data:
#  # print((item))
  
# "BARCODE_NUMBER", "VASE_ID", "ELEVATOR_ASIGN","ADD_ON_ID","LED_ASIGN"
# for i in range(11):

#   print(balanced_Data[i])
# get_database(balanced_Data)