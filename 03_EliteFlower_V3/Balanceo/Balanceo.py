print("soy una funcion de python")
# -*- coding: utf-8 -*-
"""ALGORITMO_BALANCEO_ELITE_PYTHON.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BlaA48w4FHk1hIh_PjzrD-2CPzobT5Uy



# DEFINICIÓN DE FUNCIONES
"""
from itertools import combinations
import json
from lib2to3.pytree import convert
from multiprocessing import connection
from os import getcwd
from xmlrpc.client import boolean 
from numpy.lib.function_base import append
import random
from csv import excel
import pandas as pd
import numpy as np
import pickle
import sys

"""
***********************************
Funcion para el balanceo de 1 Vase
***********************************
"""

def balanceo_1_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count):
  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio = 0
    elif (r == 2 ):
      inicio = 3
    else:
      inicio = 6
      
    for i in range(inicio,inicio+3,1):
      Distribucion_estaciones[i]  = Vases_ID[0]

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]

  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    #random.shuffle(lista_aux)   #Aleatorizar
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 2 Vases
***********************************
"""


def balanceo_2_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):  

  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];

  if cant_st == 1:
    estacion = [V_P1, V_P1, V_P2]
    random.shuffle(estacion)
  elif cant_st == 2:
    aux_1 = [V_P1, V_P1, V_P2]
    aux_2 = [V_P1, V_P2, V_P2]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    estacion = [aux_1,aux_2]
    random.shuffle(estacion)
  else:
    aux = [V_P1, V_P1, V_P2]
    random.shuffle(aux)
    estacion = [aux,aux,aux]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  if cant_st > 1 :
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[i][n]
        n+=1
  else:
    for i in range(cant_st):
      n=0
      for j in range(inicio[i],inicio[i]+3,1):
        Distribucion_estaciones[j]= estacion[n]
        n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  if cant_st == 2:
    #Determinar la cantidad de vases por elevador para asegurar el balanceo
    vases_por_st = int(round(total_con_vase / cant_st))
    cant_vase_m_por_elv = int(round(Cantidades[V_P2]/3))
    x = vases_por_st - (2*cant_vase_m_por_elv) 

    for i in range(0,9,3):
      auxiliar = Distribucion_estaciones[i:i+3]
      if auxiliar.count(V_P1) == 1:
        ubi = auxiliar.index(V_P1) + i + 1

    elevador_ID = []
    lista_aux = []

    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        R=list(elevadores_asignados[i])
        R.remove(ubi)
        for r in range(x):
          lista_aux.append(ubi)
        j = 0
        for t in range (Vases_count[i]-x):
          if j>(len(R)-1):
            j=0
          lista_aux.append(R[j])
          j=j+1
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)

  else:
    elevador_ID = []
    lista_aux = []

    for w in range(len(elevadores_asignados)):
      lista_aux = []
      j = 0
      for i in range (Vases_count[w]):
        if j>(len(elevadores_asignados[w])-1):
          j=0
        lista_aux.append(elevadores_asignados[w][j])
        j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 3 Vases
***********************************
"""

def balanceo_3_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];

  estacion = []
  aux_estacion = [V_P1, V_P2, V_P3]

  for i in range(cant_st):
    random.shuffle(aux_estacion)
    estacion += aux_estacion
  
  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  n=0
  for i in range(cant_st):
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[n]
      n+=1  

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])
  
  elevador_ID = []
  lista_aux = []

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 4 Vases
***********************************
"""

def balanceo_4_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];
  V_P4 = sort_cantidades[3][0];

  estacion = []
  aux_1 = [V_P1, V_P2, V_P4]
  aux_2 = [V_P1, V_P2, V_P3]
  random.shuffle(aux_1)
  random.shuffle(aux_2)

  if cant_st == 2:
    estacion = [aux_1,aux_2]
  else:
    estacion = [aux_1,aux_2,aux_2]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  vases_por_st = int(round(total_con_vase / cant_st))
  y = int(round(Cantidades[V_P2]/cant_st)) #Cantidad de vase de la segunda con mayor porcentaje por estación
  #Estacion con V_P3 y V_P2
  x = int(round(vases_por_st - (y + Cantidades[V_P3]/(cant_st-1))))

  elevador_ID = []
  lista_aux = []

  if cant_st == 2:
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i]-x):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x):
          lista_aux.append(elevadores_asignados[i][1])
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)

  else:
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i]-(2*x)):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x):
          lista_aux.append(elevadores_asignados[i][1])
          lista_aux.append(elevadores_asignados[i][2])
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID


"""
***********************************
Funcion para el balanceo de 5 Vases
***********************************
"""

def balanceo_5_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):
  V_P1 = sort_cantidades[0][0];
  V_P2 = sort_cantidades[1][0];
  V_P3 = sort_cantidades[2][0];
  V_P4 = sort_cantidades[3][0];
  V_P5 = sort_cantidades[4][0];

  estacion = []
  x=[]

  if cant_st == 2:
    aux_1 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P3, V_P4]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    estacion = [aux_1,aux_2]
  else:
    aux_1 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P2, V_P4] # De la estación 1 se despeja x[1]
    aux_3 = [V_P1, V_P2, V_P3]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    random.shuffle(aux_3)
    estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  vases_por_st = int(round(total_con_vase / cant_st))

  elevador_ID = []
  lista_aux = []
  x=[]

  #Estacion con V_P3 y V_P2
  if cant_st == 2:
    x += [int(round(vases_por_st - (Cantidades[V_P2] + Cantidades[V_P5])))]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i]-x[0]):
          lista_aux.append(elevadores_asignados[i][1])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)

  else:
    y = int(round(Cantidades[V_P2]/cant_st)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    x += [int(round(vases_por_st - (y + Cantidades[V_P5])))] #x[0]
    x += [int(round(vases_por_st - (y + Cantidades[V_P4])))] #x[1]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i] - x[0] - x[1]):
          lista_aux.append(elevadores_asignados[i][2])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x[1]):
          lista_aux.append(elevadores_asignados[i][1])
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 6 Vases
***********************************
"""

def balanceo_6_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]

  estacion = []
  x=[]

  if cant_st == 2:

    lista_ids_por_orden = []
    for i in range(len(sort_cantidades)):
      lista_ids_por_orden.append(sort_cantidades[i][0])
    
    Posb_Comb = []
    for c in combinations(lista_ids_por_orden, 3):
      Posb_Comb.append(c)

    suma_vases_posb_st=[]
    for i in range(len(Posb_Comb)):
      a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])][1]
      b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])][1]
      c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])][1]
      aux = a+b+c
      suma_vases_posb_st.append(aux)
    
    porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/2)))
    x = suma_vases_posb_st.index(porcentaje_mas_cercano)
    Ord_St_1 = list(Posb_Comb[x])
    
    Ord_St_2 = list(lista_ids_por_orden)
    for i in Ord_St_1:
      Ord_St_2.remove(i)
    
    random.shuffle(Ord_St_1)
    random.shuffle(Ord_St_2)
    estacion = [Ord_St_1,Ord_St_2]

  else:
    aux_1 = [V_P1, V_P2, V_P6] # De la estación 1 se despeja x[0]
    aux_2 = [V_P1, V_P2, V_P5] # De la estación 1 se despeja x[1]
    aux_3 = [V_P1, V_P3, V_P4]
    random.shuffle(aux_1)
    random.shuffle(aux_2)
    random.shuffle(aux_3)
    estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []
  x=[]

  if cant_st == 2:
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      for t in range (Vases_count[i]):
        lista_aux.append(elevadores_asignados[i][0])
      elevador_ID.append(lista_aux)
    
  else:
    vases_por_st = int(round(total_con_vase / cant_st))
    y = int(round(Cantidades[V_P2]/2)) #Cantidad de vase de la segunda con mayor porcentaje por estación
    x += [int(round(vases_por_st - (y + Cantidades[V_P6])))] #x[0]
    x += [int(round(vases_por_st - (y + Cantidades[V_P5])))] #x[1]
    for i in range(len(elevadores_asignados)):
      lista_aux = []
      if (Vases_ID[i] == V_P1):
        for h in range(Vases_count[i] - x[0] - x[1]):
          lista_aux.append(elevadores_asignados[i][2])
        for h in range(x[0]):
          lista_aux.append(elevadores_asignados[i][0])
        for h in range(x[1]):
          lista_aux.append(elevadores_asignados[i][1])
        random.shuffle(lista_aux)
      else:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[i])-1):
            j=0
          lista_aux.append(elevadores_asignados[i][j])
          j=j+1
      elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 7 Vases
***********************************
"""

def balanceo_7_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades):  
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]

  estacion = []
  x=[]
  
  aux_1 = [V_P1, V_P2, V_P7] # De la estación 1 se despeja x[0]
  aux_2 = [V_P1, V_P3, V_P6] # De la estación 2 se despeja x[1]
  aux_3 = [V_P1, V_P4, V_P5]
  random.shuffle(aux_1)
  random.shuffle(aux_2)
  random.shuffle(aux_3)
  estacion = [aux_1,aux_2,aux_3]

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  x=[]


  vases_por_st = int(round(total_con_vase / cant_st)) 
  x += [int(round(vases_por_st - (Cantidades[V_P2] + Cantidades[V_P7])))] #estacion 1 x[0]
  x += [int(round(vases_por_st - (Cantidades[V_P3] + Cantidades[V_P6])))] #estacion 2 x[1]

  if Cantidades[V_P2] >= 23 and Cantidades[V_P7] >=10: x[0] = 0

  for i in range(len(elevadores_asignados)):
    lista_aux = []
    if (Vases_ID[i] == V_P1):
      for h in range(Vases_count[i] - x[0] - x[1]):
        lista_aux.append(elevadores_asignados[i][2])
      for h in range(x[0]):
        lista_aux.append(elevadores_asignados[i][0])
      for h in range(x[1]):
        lista_aux.append(elevadores_asignados[i][1])
      random.shuffle(lista_aux)
    else:
      j = 0
      for t in range (Vases_count[i]):
        if j>(len(elevadores_asignados[i])-1):
          j=0
        lista_aux.append(elevadores_asignados[i][j])
        j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 8 Vases
***********************************
"""

def balanceo_8_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades): 
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]
  V_P8 = sort_cantidades[7][0]

  estacion = []

  lista_ids_por_orden = []

  for i in range(len(sort_cantidades)):
    lista_ids_por_orden.append(sort_cantidades[i][0])

  lista_ids_por_orden.remove(V_P1)

  Posb_Comb = []
  for c in combinations(lista_ids_por_orden, 3):
    Posb_Comb.append(c)

  suma_vases_posb_st=[]
  for i in range(len(Posb_Comb)):
    a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])+1][1]
    b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])+1][1]
    c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])+1][1]
    aux = a+b+c
    suma_vases_posb_st.append(aux)

  porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/3)))
  indice = suma_vases_posb_st.index(porcentaje_mas_cercano)
  Ord_St_1 = list(Posb_Comb[indice])

  for i in Ord_St_1:
    lista_ids_por_orden.remove(i)

  Ord_St_2 = [V_P1,lista_ids_por_orden[0],lista_ids_por_orden[3]]
  Ord_St_3 = [V_P1,lista_ids_por_orden[1],lista_ids_por_orden[2]]

  aux_vase_St_2 = list(Ord_St_2)

  random.shuffle(Ord_St_1)
  random.shuffle(Ord_St_2)
  random.shuffle(Ord_St_3)
  estacion = [Ord_St_1,Ord_St_2,Ord_St_3] #El orden debe ser extricto 

  inicio = []

  for i in range(cant_st):
    r = var_ext_estaciones_slc[i]
    if (r == 1 ):
      inicio.append(0)
    elif (r == 2 ):
      inicio.append(3)
    else:
      inicio.append(6)

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []

  vases_por_st = int(round(total_con_vase / cant_st))
  x = [int(round(vases_por_st - (Cantidades[aux_vase_St_2[1]] + Cantidades[aux_vase_St_2[2]])))] # X de la estación 2

  for i in range(len(elevadores_asignados)):
    lista_aux = []
    if (Vases_ID[i] == V_P1):
      for h in range(Vases_count[i] - x[0]):
        lista_aux.append(elevadores_asignados[i][1])
      for h in range(x[0]):
        lista_aux.append(elevadores_asignados[i][0])
      random.shuffle(lista_aux)
    else:
      j = 0
      for t in range (Vases_count[i]):
        if j>(len(elevadores_asignados[i])-1):
          j=0
        lista_aux.append(elevadores_asignados[i][j])
        j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID

"""
***********************************
Funcion para el balanceo de 9 Vases
***********************************
"""

def balanceo_9_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades): 
  V_P1 = sort_cantidades[0][0]
  V_P2 = sort_cantidades[1][0]
  V_P3 = sort_cantidades[2][0]
  V_P4 = sort_cantidades[3][0]
  V_P5 = sort_cantidades[4][0]
  V_P6 = sort_cantidades[5][0]
  V_P7 = sort_cantidades[6][0]
  V_P8 = sort_cantidades[7][0]
  V_P9 = sort_cantidades[8][0]

  estacion = []

  lista_ids_por_orden = []

  for i in range(len(sort_cantidades)):
    lista_ids_por_orden.append(sort_cantidades[i][0])

  Lista_AUX = list(lista_ids_por_orden)

  for r in range(2):
    Posb_Comb = []
    
    for c in combinations(Lista_AUX, 3):
      Posb_Comb.append(c)
    suma_vases_posb_st=[]
    
    for i in range(len(Posb_Comb)):
      a=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][0])][1]
      b=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][1])][1]
      c=sort_cantidades[lista_ids_por_orden.index(Posb_Comb[i][2])][1]
      aux = a+b+c
      suma_vases_posb_st.append(aux)
    
    porcentaje_mas_cercano = min(suma_vases_posb_st, key=lambda x:abs(x-(total_con_vase/3)))
    indice = suma_vases_posb_st.index(porcentaje_mas_cercano)
    Ord_St_ = list(Posb_Comb[indice])
    for i in Ord_St_:
      Lista_AUX.remove(i)
    random.shuffle(Ord_St_)
    estacion.append(Ord_St_)

  random.shuffle(Lista_AUX)
  estacion.append(Lista_AUX)
  random.shuffle(estacion) 

  inicio = [0,3,6]

  for i in range(cant_st):
    n=0
    for j in range(inicio[i],inicio[i]+3,1):
      Distribucion_estaciones[j]= estacion[i][n]
      n+=1

  elevadores_asignados = []
  elevadores_asignados_aux = []
  for r in range(Vases_type_num):
    indices = [i for i, x in enumerate(Distribucion_estaciones) if  x == Vases_ID[r]]
    elevadores_asignados_aux.append(indices)

  elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  if '-1' in Vases_ID:
    elevadores_asignados.append([-1])

  elevador_ID = []
  lista_aux = []

  for w in range(len(elevadores_asignados)):
    lista_aux = []
    j = 0
    for i in range (Vases_count[w]):
      if j>(len(elevadores_asignados[w])-1):
        j=0
      lista_aux.append(elevadores_asignados[w][j])
      j=j+1
    elevador_ID.append(lista_aux)
  return elevadores_asignados, elevador_ID


"""# CARGAR BASE DE DATOS

"""
def balanceo_automatico(var_ext_estaciones_slc, df_original):

   


  # Se carga la base de datos desde el archivo de excel

  #df_original = pd.read_excel('/content/DB_PRUEBA_1_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_2_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_3_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_4_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_5_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_6_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_7_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_8_V.xlsx')
  #df_original = pd.read_excel('/content/DB_PRUEBA_9_V.xlsx')
  df_original = pd.read_excel (df)
  #print (df_original)
  df_original = df_original.replace(np.nan,'-1')
  db_g = df_original.groupby('VASE_ID', dropna=False).agg(list)
  #print("base de datos")
  #print(db_g)
  dp = getcwd()
  #file1 = open(rf'{dp}\intercambio.txt', "wb") # cambiar la direccion de guardado de acuerdo al proyecto, solo cambiar ruta, wb se mantiene
  #pickle.dump(db_g, file1)
  #file1.close

  """#PROCESAR"""

  #with open(rf'{dp}\intercambio.txt', 'rb') as f:
      #db_group = pickle.load(f)
  db_group = db_g    
  #print(db_group)
  Vases_ID = db_group.index.values
  Barcodes = db_group.BARCODE_NUMBER.values
  AddOn_List = db_group.ADD_ON_ID.values
  Total_ordenes = 0;
  for i in range(Barcodes.shape[0]):
    Total_ordenes += len(Barcodes[i]) 

  if '-1' in Vases_ID:
    Vases_ID = np.roll(Vases_ID, -1)
    Barcodes = np.roll(Barcodes, -1)
    AddOn_List = np.roll(AddOn_List, -1)
    Vases_type_num = db_group.index.size - 1
    N_V = len(Barcodes[-1])
  else:
    Vases_type_num = db_group.index.size - 1
    N_V = 0

  Vases_count = np.zeros((Vases_ID.size), dtype=int)
  for i in range(Vases_ID.size):
    Vases_count[i]=len(Barcodes[i])

  AddOn_ID = ["","",""]
  for i in range(len(AddOn_List)):
    AddOn_ID = np.append(AddOn_ID,np.unique(AddOn_List[i]))
  AddOn_ID = np.unique(AddOn_ID)
  if '-1' in AddOn_ID:
    AddOn_ID = np.delete(AddOn_ID,np.where(AddOn_ID =='-1')[0][0])

  AddOn_count=[0,0,0]
  aux = []
  aux1 = []

  for i in range(AddOn_List.size):
    aux = []
    a = AddOn_List[i]
    for j in range(AddOn_ID.size):
      b = a.count(AddOn_ID[j])
      aux.append(b)
    aux1.append(aux)
  aux1 = np.array(aux1)

  AddOn_count = np.sum(aux1, axis=0)

  total_con_vase = 0
  for i in range(Vases_type_num):
    total_con_vase = total_con_vase + Vases_count[i]

  Cantidades = {}
  for i in range(Vases_type_num):
    Cantidades[Vases_ID[i]] = Vases_count[i]

  # take the second element for sort
  def take_second(elem):
      return elem[1]

  sort_cantidades = sorted(Cantidades.items(),  key=take_second, reverse=True)

  ### ESTO ES UNA ENTRADA DIRECTA DE LA UI ###
  ## INGRESAR UNA LISTA CON LAS ESTACIONES SELECCIONADAS
  #Se escogen cuantas y cuales estaciones seran utilizadas #
  #var_ext_estaciones_slc = ['3']
  #var_ext_estaciones_slc = ['2','1']
  #var_ext_estaciones_slc = ['2','3','1']
  var_ext_estaciones_slc = list(map(int, var_ext_estaciones_slc))
  var_ext_estaciones_slc.sort()
  cant_st = len(var_ext_estaciones_slc)
  Distribucion_estaciones = ['-1','-1','-1','-1','-1','-1','-1','-1','-1'] # elevadores
 
  if cant_st*3 < Vases_type_num:
    print("!ERROR! -> La cantidad de vases supera el número de elevadores seleccionados")

  else:
    #print(f"Addon Id: {AddOn_ID}")
    Led_Pos = ['N_A','N_A','N_A']
    for i in range(AddOn_ID.size):
      Led_Pos[i] = AddOn_ID[i]

    lista_aux = []
    Led_ID = []

    for i in range(AddOn_List.size):
      lista_aux = []
      for j in range(len(AddOn_List[i])):
        if AddOn_List[i][j] == '-1':
          lista_aux.append('-1')
        elif AddOn_List[i][j] == Led_Pos[0]:
          lista_aux.append('1')
        elif AddOn_List[i][j] == Led_Pos[1]:
          lista_aux.append('2')
        elif AddOn_List[i][j] == Led_Pos[2]:
          lista_aux.append('3')
      Led_ID.append(lista_aux)

    strg_to_print = ""
    for j in range(Vases_type_num):
      strg_to_print += str(Vases_count[j]) + ' órdenes con ' + Vases_ID[j] +"\n"

    strg_to_print = strg_to_print + str(N_V) + ' órdenes sin vase '

    print("Total de órdenes ingresadas = " + str(Total_ordenes))
    print(strg_to_print)

    strg_to_print = ""
    for j in range(AddOn_count.size):
      strg_to_print += "\n" + str(AddOn_count[j]) + ' órdenes con addon ' + AddOn_ID[j]

    print(strg_to_print)

  """# BALANCEO AUTOMÁTICO"""

  if Vases_type_num == 1:
    elevadores_asignados, elevador_ID = balanceo_1_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count)
  elif Vases_type_num == 2:
    elevadores_asignados, elevador_ID = balanceo_2_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 3:
    elevadores_asignados, elevador_ID = balanceo_3_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 4:
    elevadores_asignados, elevador_ID = balanceo_4_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 5:
    elevadores_asignados, elevador_ID = balanceo_5_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 6:
    elevadores_asignados, elevador_ID = balanceo_6_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 7:
    elevadores_asignados, elevador_ID = balanceo_7_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 8:
    elevadores_asignados, elevador_ID = balanceo_8_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)
  elif Vases_type_num == 9:
    elevadores_asignados, elevador_ID = balanceo_9_vase(cant_st,var_ext_estaciones_slc, Distribucion_estaciones, Vases_ID, Vases_type_num, Vases_count, sort_cantidades, total_con_vase, Cantidades)

  """# SALIDA Y VISUALIZACIÓN DE LA BASE DE DATOS CON LA ASIGNACIÓN EJECUTADA

  """

  base_datos_output = []

  for w in range(len(Vases_ID)):
    CdB = Barcodes[w]
    V_ID = Vases_ID[w]
    AO_ID = AddOn_List[w]
    ELEV_ID = elevador_ID[w]
    LED_AO = Led_ID[w]
    for q in range(Vases_count[w]):
      lista_aux = [CdB[q], V_ID, ELEV_ID[q], AO_ID[q],LED_AO[q]]
      base_datos_output.append(lista_aux)

  Cuenta_Elevador = []
  for i in range(9):
    acumulador = 0
    for k in range(len(elevador_ID)):
      acumulador +=  elevador_ID[k].count(i+1)
    Cuenta_Elevador.append(acumulador)

  Balanceo = []
  for i in range (len(Distribucion_estaciones)):
    Balanceo.append([Distribucion_estaciones[i],Cuenta_Elevador[i]])

  Dist_Led_AD =[]
  for i in range(AddOn_ID.size):
    Dist_Led_AD.append((AddOn_ID[i],AddOn_count[i]))

  print("Total de órdenes ingresadas con vase = " + str(total_con_vase))
  print("Pedidos con vases ordenados de mayor a menor:", sort_cantidades)
  print("Estaciones seleccionadas:", var_ext_estaciones_slc)
  print("Distribución en los elevadores: ", Distribucion_estaciones)
  print("Balanceo ejecutado:", Balanceo)
  print("Leds Add-On:", Dist_Led_AD)

  panda_df = pd.DataFrame(data = base_datos_output, columns = ["BARCODE_NUMBER", "VASE_ID", "ELEVATOR_ASIGN","ADD_ON_ID","LED_ASIGN"])
 #panda_df

  """# ASIGNACIÓN MANUAL"""

  Asignacion_Selec = ['-1','-1','-1','GINGER', 'SLENDER' ,'-1','LARGE', 'GINGER', 'GINGER'] # Lista extraida directamente de la elección que hace el usuario en la interfaz
  #Los presets son simplemente listas que se puedan almacenar en la base de datos 

 # Distribucion_estaciones = Asignacion_Selec

  Vases_ID_select = np.unique(Asignacion_Selec)

  if '-1' in Asignacion_Selec:
    Vases_ID_select = np.roll(Vases_ID_select, -1)
    cant_vases_selec = len(Vases_ID_select) - 1
  else:
    cant_vases_selec = len(Vases_ID_select) 

  continuar = 's'

  if (Vases_type_num!= cant_vases_selec):
    continuar = input("La cantidad de vases seleccionadas no corresponde con la cantidad de bases en el archivo de excel. ¿Desea continuar? S/N ")

  if continuar.lower() == 's':
    elevadores_asignados = []
    elevadores_asignados_aux = []
    for r in range(cant_vases_selec):
      indices = [i for i, x in enumerate(Asignacion_Selec) if  x == Vases_ID_select[r]]
      elevadores_asignados_aux.append(indices)
    
    elevadores_asignados = [[y+1 for y in x ] for x in elevadores_asignados_aux]
  
    if '-1' in Vases_ID:
      elevadores_asignados.append([-1])

    elevador_ID = []
    lista_aux = []
    n = 0
    j = 0
    for i in range(len(Vases_ID)):
      lista_aux = []
      if Vases_ID[i] in Vases_ID_select:
        j = 0
        for t in range (Vases_count[i]):
          if j>(len(elevadores_asignados[n])-1):
            j=0
          lista_aux.append(elevadores_asignados[n][j])
          j=j+1
        n += 1
      else:
        for t in range (Vases_count[i]):
          lista_aux.append(-1)
      elevador_ID.append(lista_aux)

  else:
    print("Asigne nuevamente los elevadores")

  get_db_statics(Total_ordenes,total_con_vase, sort_cantidades, var_ext_estaciones_slc, Balanceo,Distribucion_estaciones,Cuenta_Elevador, Dist_Led_AD, AddOn_ID, AddOn_count)
  return base_datos_output
  """# Crear y cargar TXTs

  """
"""

  #Creo
  file1 = open("/intercambio.txt", "wb")
  pickle.dump(df_agrupado, file1)
  file1.close

  #Cargo
  with open('/intercambio.txt', 'rb') as f:
      db_group = pickle.load(f)
"""

"""
****************************************************************
Asignación de variables para prueba, comentar en la aplicación
****************************************************************
"""
def get_database(data):
    import pymongo
    client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')
    db = client['EliteFlower']
    print(client)
    #print(data)


    
    balanceData = db.balanceData
    balanceData.delete_many({}) #borra todos los elementos de la coleccion
    Data = db.Data
    whstage = -1
    for item in data:
      #print(item[4])
      if item[3] == -1:
        Whstage = -1
      else:
        whstage = 1
      if item[1] == "-1":
        item[1] = "null"
      else:
        pass
      if item[3] == "-1":
        item[3] = "null"
      else:
        pass

      jsondata = {'TrackingNumber': item[0],
                  'Vase': item[1],
                  'Balance': item[2],
                  'AddOnId':item[3],
                  'AddOnBalance': item[4],
                  'WhStage': whstage                 
                 }
      balanceData.insert_one(jsondata)
      db.Data.update_many({"TrackingNumber":item[0]},{"$set":{'Vase': item[1],'Balance': item[2],'AddOnId':item[3],'AddOnBalance': item[4],'WhStage': whstage}})
    client.close()

def Convert(tup, di):
    di = dict(tup)
    return di
    

def get_db_statics(Total_ordenes,total_con_vase, sort_cantidades, var_ext_estaciones_slc, Balanceo,Distribucion_estaciones,Cuenta_Elevador, Dist_Led_AD,AddOn_ID, AddOn_count):
  print('from statics')
  import pymongo
  from collections import defaultdict
  client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')
  db = client['EliteFlower']
  #print(client)

  Statics = db.Statics
  Statics.delete_many({}) #borra todos los elementos de la coleccion

  # record = {'Total con Vase':total_con_vase,
  #           'Ordenes segun Vase':sort_cantidades,
  #           'Estaciones seleccionadas':var_ext_estaciones_slc,
  #           'Distribucion':Distribucion_estaciones,
  #           'Balanceo': Balanceo,
  #           'AddON': Dist_Led_AD}
  # Driver Code    

  dictionary = {} 
  dic_sort_cant = Convert(sort_cantidades,dictionary)
  for keys in dic_sort_cant:
    dic_sort_cant[keys] = str(dic_sort_cant[keys])


  dictionary = {} 
  dic_AddON = Convert(Dist_Led_AD,dictionary)
  for keys in dic_AddON:
    dic_AddON[keys] = str(dic_AddON[keys])

  print (f'Estaciones = {type(Distribucion_estaciones)}')
  print (f'addon = {type(AddOn_ID)}')
  record = { "_id" : 1,
            "Total_Orders": str(Total_ordenes),
            "Total_Vases": str(total_con_vase),
            "Orders": dic_sort_cant, 
            "Active_Stations": var_ext_estaciones_slc,
            "Estaciones": Distribucion_estaciones,
            "Cuenta_Estaciones" : Cuenta_Elevador,
             "AddON" : AddOn_ID.tolist(),
             "Cuenta_AddON" : AddOn_count.tolist()
            # "File" : "Data"
            }

  print(record)

 

  #result = json.dumps(record)
  
  #print(result)
  #record_j = json.dumps(record)
  

  #print(record_j)

  Statics.insert_one(record)
  client.close()



      


 
    
# This is added so that many files can reuse the function get_database()


dp = 'D:\GitHub\EliteFlowerDeploy_V3\03_EliteFlower_V3'   # direccion del proyecto


#dp = getcwd(
var_ext_estaciones_slc = [sys.argv[1],sys.argv[2],sys.argv[3]]
estaciones_activas = []
print(sys.argv[4])

if ((sys.argv[4]) == "FilePath: "): 
  df = 'D:\GitHub\EliteFlowerDeploy_V3\DataBases\Prueba_Python.xlsx' #direccion de la base de datos
else:
  print("df es =")  
  df = sys.argv[4]


print(df)  
#print(df)
s = 'True'
#print(len(var_ext_estaciones_slc))
i = 1
for item in var_ext_estaciones_slc:
  #print(item)
  if item == s:
    estaciones_activas.append(i)
    i +=1 
  else:
    i +=1 
    pass


#print(estaciones_activas) 

balanced_Data = balanceo_automatico(estaciones_activas,df)
print("Data balanceda = ")
#for item in balanced_Data:
 # print((item))
  
"BARCODE_NUMBER", "VASE_ID", "ELEVATOR_ASIGN","ADD_ON_ID","LED_ASIGN"
for i in range(11):

  print(balanced_Data[i])
get_database(balanced_Data)